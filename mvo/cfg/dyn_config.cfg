#!/usr/bin/env python
PACKAGE = "mvo"
from dynamic_reconfigure.parameter_generator_catkin import *
gen = ParameterGenerator()

#TrackerDetector
track_detector = gen.add_group("tracker_detector")
track_detector.add("numberOfFeatures",int_t, 1,"The number of features to track", 60, 4,1000)
track_detector.add("qualityLevel", double_t, 1, "Minimum quality of the detected features", 0.2, 0,1)
track_detector.add("windowSizeX", int_t, 1, "SizeX of the search window at each pyramid level", 21, 3, 60)
track_detector.add("windowSizeY", int_t, 1, "SizeY of the search window at each pyramid level", 21, 3, 60)
track_detector.add("k", double_t,1, "Free parameter of the Harris detector", 0.04, 0,1)
track_detector.add("blockSize", double_t, 1, "Size of an average block for in Harris detector computing a derivative covariation matrix over each pixel neighborhood", 3,1,60)
track_detector.add("mindDiffPercent", double_t, 1, "Mimum percentual difference of the Image needed between features", 0.01, 0,1)
track_detector.add("pyramidDepth",int_t, 1, "Th edepth of Pyramide", 3,1,10)



#Merging
merger = gen.add_group("merger")
merger.add("sameDisparityThreshold", double_t,1,"Minium percentual difference over all features before a frame is considered as a new position", 0.0001,0,1)
merger.add("movementDisparityThreshold", double_t,1,"Minmium percenutal difference over all features needed to start a position estiamtion", 0.05, 0,1)

#BaseLineEstimation
estimator = gen.add_group("epopolar_geometry_baseline_estimator")
estimator.add("thresholdOutlier", double_t, 1, "degrees of the RANSAC-Costfunction when to detect outliers", 4,0,45)
estimator.add("bestFitProbability", double_t,1,"probability to have the perfect inlier-set of featuretracking RANSAC", 0.99,0.1)

#IterativeRefinement/Refiner
refiner = gen.add_group("iterative_refinement_refiner")
refiner.add("lowestLength", double_t, 1, "the lowest length a movement can have", 0.25)
refiner.add("highestLength", double_t, 1, "the highest length a movement can have", 2)
refiner.add("maxNumThreads", int_t,1,"the maximum of threads used by the Solver (e.g. to calculate he jacobian or the error", 4, 1, 16)
refiner.add("maxNumIterations", int_t,1,"Maximum number of iterations for which the solver should run", 50, 1,5000)
refiner.add("functionTolerance", double_t,1,"Solver terminates if the relative improvement to the cost function in the last step is smaller than this", 1e-9, 1e-1,1e-30)
refiner.add("useLossFunction", bool_t,1,"Wether the Solver should use a lossfunction to be more independent rom outliers", False)

exit(gen.generate(PACKAGE, "mvo_node", "mvo"))